---
title: About the aws_security_group Resource
---

# aws\_security\_group

Use the `aws_security_group` InSpec audit resource to test detailed properties of an individual Security Group (SG).

SGs are a networking construct which contain ingress and egress rules for network communications.  SGs may be attached to EC2 instances, as well as certain other AWS resources.  Along with Network Access Control Lists, SGs are one of the two main mechanisms of enforcing network-level security.

<br>

## Syntax

An `aws_security_group` resource block uses resource parameters to search for a Security Group and then tests that Security Group. If no SGs match, no error is raised, but the `exists` matcher returns `false` and all properties will be `nil`. If more than one SG matches (due to vague search parameters), an error is raised.

    # Ensure you have a security group with a certain ID
    # This is "safe" - SG IDs are unique within an account
    describe aws_security_group('sg-12345678') do
      it { should exist }
    end

    # Ensure you have a security group with a certain ID
    # This uses hash syntax
    describe aws_security_group(id: 'sg-12345678') do
      it { should exist }
    end

<br>

## Examples

The following examples show how to use this InSpec audit resource.

    # Ensure that the linux_servers group permits SSH from the 10.5.0.0/16 range, but not the world
    describe aws_security_group(group_name: linux_servers) do
      # This passes if there is any inbound rule that specifies 
      # port 22 and the given IP range, regardless of protocol, etc.
      its('inbound_rules') { should allow(port: 22, ipv4_range: '10.5.0.0/16') }

      # This passes so long as there is no inbound rule that specifies port 22
      # and whose source IP range is 0.0.0.0/0.  Other properties are ignored. 
      its('inbound_rules') { should_not allow(port: 22, ipv4_range: '0.0.0.0/0') }

      # This is an alternate way of expressing the previous test.
      # be_open_to_the_world_on_port assumes you want inbound_rules.
      it { should_not be_open_to_the_world_on_port(22) }
    end

    # Ensure that the careful_updates group may only initiate contact with certain IPs.
    describe aws_security_group(group_name: 'careful_updates') do

      # If you have two rules, with one CIDR each: 
      [ '10.7.23.12/32', '10.8.23.12/32'].each do |allowed_destination|
        # this doesn't care about which ports are enabled
        its('outbound_rules') { should allow(ipv4_range: allowed_destination)}
      end

      # If you have one rule, with two CIDRs: 
      its('outbound_rules') { should allow(ipv4_range: ['10.7.23.12/32', '10.8.23.12/32']}

      # Expect exactly three rules.
      its('outbound_rules.count') { should cmp 3 }
    end

<br>

## Resource Parameters

This InSpec resource accepts the following parameters, which are used to search for the Security Group.

### id, group\_id

The Security Group ID of the Security Group. This is of the format `sg-` followed by 8 hexadecimal characters.  The ID is unique within your AWS account; using ID ensures that you will never match more than one SG. The ID is also the default resource parameter, so you may omit the hash syntax.

    # Using Hash syntax
    describe aws_security_group(id: 'sg-12345678') do
      it { should exist }
    end

    # group_id is an alias for id
    describe aws_security_group(group_id: 'sg-12345678') do
      it { should exist }
    end

    # Or omit hash syntax, rely on it being the default parameter
    describe aws_security_group('sg-12345678') do
      it { should exist }
    end

### group\_name

The string name of the Security Group.  Every VPC has a security group named 'default'. Names are unique within a VPC, but not within an AWS account.

    # Get default security group for a certain VPC
    describe aws_security_group(group_name: 'default', vpc_id: vpc_id: 'vpc-12345678') do
      it { should exist }
    end

    # This will throw an error if there is a 'backend' SG in more than one VPC.
    describe aws_security_group(group_name: 'backend') do
      it { should exist }
    end

### vpc\_id

A string identifying the VPC that contains the security group. Since VPCs commonly contain many SGs, you should add additional parameters to ensure you find exactly one SG.

    # This will error if there is more than the default SG
    describe aws_security_group(vpc_id: 'vpc-12345678') do
      it { should exist }
    end

<br>
## Properties

* `description`, `group_id`, `group_name`, `inbound_rules`, `outbound_rules`, `vpc_id`

<br>

## Property Examples

### description

A String reflecting the human-meaningful description that was given to the SG at creation time.

    # Require a description of a particular group
    describe aws_security_group('sg-12345678') do
      its('description') { should_not be_empty }
    end

### group\_id

Provides the Security Group ID.

    # Inspect the group ID of the default group
    describe aws_security_group(group_name: 'default', vpc_id: vpc_id: 'vpc-12345678') do
      its('group_id') { should cmp 'sg-12345678' }
    end

    # Store the group ID in a Ruby variable for use elsewhere
    sg_id = aws_security_group(group_name: 'default', vpc_id: vpc_id: 'vpc-12345678').group_id

### group\_name

A String reflecting the name that was given to the SG at creation time.

    # Inspect the group name of a particular group
    describe aws_security_group('sg-12345678') do
      its('group_name') { should cmp 'my_group' }
    end

### inbound_rules

A list of the rules that the security group applies to incoming network traffic. This is usually used with the [`allow`](#allow) and [`reject`](#reject) matchers; see them for detailed examples. Order is very important in these rules, as the sequentially first rule to match will be applied to network traffic. By default, AWS includes a reject-all rule as the last inbound rule.

If the security group could not be found (that is, `exists` is false), `inbound_rules` will return an empty list.

    describe aws_security_group(group_name: linux_servers) do
      # This passes if there is any inbound rule that includes 
      # port 22 and the given IP range, regardless of protocol, etc.
      its('inbound_rules') { should allow(port: 22, source '10.5.0.0/16') }

      # You can also treat it at the lower level, as an array of hashes.
      # This bypasses all smart matching, like port range inclusion
      its('inbound_rules.first') { should include(action: 'ACCEPT', from: '22', source: '10.2.17.0/24') }
    end

### outbound_rules

A list of the rules that the security group applies to outgoing network traffic initiated by the AWS resource in the security group. This is usually used with the [`allow`](#allow) and [`reject`](#reject) matchers; see them for detailed examples. Order is very important in these rules, as the sequentially first rule to match will be applied to network traffic. Outbound rules are typically used when it is desirable to restrict which portions of the internet, if any, a resource may access. By default, AWS includes an allow-all rule as the last outbound rule.

If the security group could not be found (that is, `exists` is false), `outbound_rules` will return an empty list.

    describe aws_security_group(group_name: isolated_servers) do
      # Its last rule should be to reject everything
      its('outbound_rules') { should reject(dest: '0.0.0.0/0', position: :last) }

      # You can also treat it at the lower level, as an array of hashes.
      # This bypasses all smart matching, like port range inclusion
      its('outbound_rules.last') { should include(action: 'REJECT', dest: '0.0.0.0/0') }
    end

### vpc\_id

A String in the format 'vpc-' followed by 8 hexadecimal characters reflecting VPC that contains the security group.

    # Inspec the VPC ID of a particular group
    describe aws_security_group('sg-12345678') do
      its('vpc_id') { should cmp 'vpc-12345678' }
    end

<br>

## Matchers

This InSpec audit resource has the following special matchers. For a full list of available matchers, please visit our [matchers page](https://www.inspec.io/docs/reference/matchers/).

### allow

For use with the `inbound_rules` and `outbound_rules` properties, the `allow` matcher enables you to perform queries about what network traffic would be permitted through the security group rule set. `allow` takes a key-value list of search criteria:

  * from_port - Determines if there is a rule whose port range begins at the specified number. The word 'from_' does not relate to inbound/outbound directionality; it relates to the port range ("counting _from_").
  * ipv4_range - Specifies an IPv4 address or subnet as a CIDR, or a list of them, to be checked as a permissible origin (for `inbound_rules`) or destination (for `outbound_rules`) for traffic.  Each security group rule may have multiple allowed source IP ranges. If the criterion specifies a single CIDR, the rule must also specify a single CIDR and they must match exactly.  If a list is provided, the rule must also supply a list, and the two lists must match exactly, ignoring order.
  * port - Determines if a particular TCP/IP port is allowed exactly; that is, there is a port range that starts and stop on this number. You may specify the port as a string (`'22'`) or as a number.
  * position - A one-based index into the list of rules. If provided, this restricts the evaluation to the rule at that position. You may also use the special values `:first` and `:last`.
  * protocol - Specifies the IP protocol. 'tcp', 'udp', and 'icmp' are some typical values.
  * to_port - Determines if there is a rule whose port range ends at the specified number. The word 'to_' does not relate to inbound/outbound directionality; it relates to the port range ("counting _to_").
  
    describe aws_security_group(group_name: 'example-group') do
      # Allow RDP from certain range
      its('inbound_rules') { should allow(port: 3389, ipv4_range: '10.5.0.0/16')}

      # Allow SSH from two ranges
      its('inbound_rules') { should allow(port: 22, ipv4_range: ['10.5.0.0/16', '10.2.3.0/24'])}

      # Check Bacula port range
      its('inbound_rules') { should allow(from_port: 9101, to_port: 9103, ipv4_range: '10.6.7.0/24')}

      # Ensure the 3rd outbound rule is TCP-based
      its('outbound_rules') { should allow(protocol: 'tcp', position: 3')}

      # Don't allow any service to be open to the world
      its('inbound_rules') { should_not allow(source: '0.0.0.0/0')}
    end

### be_open_to_the_world

This high-level matcher will cause the control to pass if there is any inbound rule that is open to `0.0.0.0/0`, regardless of port.  This is intended to be used with `should_not`.

Note that as of this release, this matcher does not consider:
  * Worldwide IPv6 access
  * Transitive access from other unsecured security groups

    describe aws_security_group(group_name: 'no-access') do
      it { should_not be_open_to_the_world }
    end

### be_open_to_the_world_on_port

This high-level matcher will cause the control to pass if there is any inbound rule that is open to `0.0.0.0/0`, on a specific port.

Note that as of this release, this matcher does not consider:
  * Worldwide IPv6 access
  * Transitive access from other unsecured security groups

    describe aws_security_group(group_name: 'webservers') do
      it { should be_open_to_the_world_on_port(80) }
      it { should be_open_to_the_world_on_port(443) }
      it { should_not be_open_to_the_world_on_port(22) }
      it { should_not be_open_to_the_world_on_port(3389) }
      its(inbound_rules.count) { should cmp 4 }   
    end

### exists

The control will pass if the specified SG was found.  Use `should_not` if you want to verify that the specified SG does not exist.

    # You will always have at least one SG, the VPC default SG
    describe aws_security_group(group_name: 'default')
      it { should exist }
    end

    # Make sure we don't have any security groups with the name 'nogood'
    describe aws_security_group(group_name: 'nogood')
      it { should_not exist }
    end

### reject

For use with the `inbound_rules` and `outbound_rules` properties, the `reject` matcher enables you to perform queries about what network traffic would _not_ be permitted through the security group rule set. `reject` takes the same key-value list of search criteria as [`allow`](#allow).